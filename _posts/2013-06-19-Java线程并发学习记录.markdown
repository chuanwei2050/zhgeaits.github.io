---
layout: post
title: "Java线程并发学习记录"
date: 2013-06-19 23:12:54
categories: java
type: technology
---

>_在面试的时候发现自己其实对于java线程并发学习还是不够，而且学过没有好好记录下载，现在就重新记录一下，然后还有线程池的学习，以后继续补充_
>
>__1\.__java的锁是对象锁，一般每个对象都有一个锁，并且有一个计数器(获得锁的意思是进入sychronzied区)，当获得锁后，计数器加一，只有第一个获得锁的任务在继续获得锁，才能够让计数器累加。同一个对象锁才能够实现同步。  
>
>__2\.__wait()方法，挂起，并且释放对象锁，与sleep和yeild对比。wait，notify等方法属于object类继承而来，所以这些方法只有在同步的对象上调用有效。  
>
>__3\.__sychronzied锁定同步对象的方法，只有任务（线程）获得锁以后才能执行，否则被阻塞。sychronzied(object){}可以用来锁定临界区，注意的是，这个锁与括号里面的对象锁同步。任务退出sychronzied的区域后自动释放锁，但是调用wait被阻塞的线程必须要唤醒才能执行，所以要调用notify等方法。  
>
>__4\.__java的线程是抢占式的，这表示调度机制会周期性地中断线程，将上下文切换到另一个线程，从而为每个线程都提供时间片，使得每个线程都会分配到数量合理的时间去驱动它的任务。  
>
>__5\.__进程是资源分配单位，主要是指分配内存地址空间，线程是调度单位，因为每行代码是一个指令，所以CPU在一个进程里面并发调度指令执行，线程共享进程的资源，就是全局变量和堆空间，但是有自己的私有栈。cpu的时间片也算一种资源，前面的资源是指空间。  
>
>__6\.__Thread.yeild()将cpu从一个线程转移到另一个线程。对于任何重要的控制或者调整应用时，都不能依赖yield()。  
>
>__7\.__使用线程池：CachedThreadPool和FixedThreadPool,SingleThreadExecutor，管理线程高效。  
>
>__8\.__一个线程可以在其他线程之上调用join()方法（意思是一个线程拿到第二线程的引用，然后调用第二个线程的join()方法），其效果是等待一段时间直到第二线程结束才继续执行。如果某个线程在另一个线程t上调用t.join()，此线程被挂起，直到目标线程t结束才恢复。  
>
>__9\.__可以使用lock对象进行锁定，就像c语言一样,结合condition使用。  
>
>__10\.__线程本地存储ThreadLocal，是一种自动化机制，可以为使用相同变量的每个不同的线程都创建不同的存储。  
>
>__11\.__如果希望线程执行产生返回值，则实现Callable接口，这个一个泛型！使用executorservice时使用submit方法，而不是execute方法。  
>
>__12\.__对一个executorservice的shutdown调用可以防止新任务被提交到这个Exector。  
>
>__13\.__所谓后台线程，是指在程序运行的时候在后台提供一种通用服务的线程，并且这种线程并不属于程序中不可或缺的部分。因此，当所有的非后台线程结束时，程序也就终止了，同时会杀死进程中的所有后台线程。反过来说，只要有任何非后台线程还在运行，程序就不会终止。后台线程在不执行finally子句的情况下就会终止run方法。  
>
