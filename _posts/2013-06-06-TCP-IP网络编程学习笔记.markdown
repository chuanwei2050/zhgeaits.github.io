---
layout: post
title:  "TCP/IP网络编程学习笔记"
date:   2013-06-06 20:12:03
categories: Unix
type: technology
---

>**第一章**
>
>1.事实上，只要一个程序员设计了两个使用TCP/IP通信的程序，这个程序员就已经发明了一种新的应用协议。
>2.TELNET协议可以用来访问不同于标准的远程登录服务的其他服务。
>3.所有的协议设计的目的都是寻找一个适用于多种应用的基本抽象。
>
>
>**第二章**
>
>1.服务器要处理的安全问题：鉴别，授权，数据安全，保密，保护。  
>2.在设计客户应用软件时，最好让它包含一些允许用户全部指明目的机器和目的协议端口号的参数。
>
>
>**第三章**
>
>* 一个进程包括一段地址空间和至少一个执行的线程。线程最重要的信息是一个指令指针，他指明进程正在执行的地址。  
>- 当多个线程并发执行一段代码时，每个线程拥有自己的过程激活记录运行时栈（run-time stack）。  
>- select调用：它允许一个程序询问操作系统哪个IO设备已准备就绪。这里IO设备包括TCP。当某个输入源就绪后，select调用立即返回，程序就可以从这个输入源中读取数据了。  
>- 对一个单处理器的体系结构来说，单个CPU在任一时刻只能执行一个线程。  
>
>
>**第四章：**
>
>1.Unix IO的六个基本操作API：open, close, read, write, lseek, ioctl
>
>
>**第五章：**
>
>1.套接字API提供了许多综合的功能，这些功能支持使用众多可能的协议进行网络通信。套接字调用把所有TCP/IP协议看作一个单一的协议族。
>  这些调用允许程序员指明所要求的服务而不是指明某个特定的协议的名字。
>2.socket()本质是分配了一个数据结构，里面还没有信息或者信息不全。
>3.如果服务器将套接字配置为等待传入连接，则称为被动（passive）套接字；反之，客户用来发起连接的套接字称为主动（active）套接字。
>4.TCP/IP协议族表示为PF_INET,地址族表示为AF_INET，两个符号常量都是2.
>5.为使程序可移植和可维护，TCP/IP代码不能在声明中使用sockaddr结构。这种结构只能用于覆盖，而且代码只能引用该结构中的sa_family字段。
>  应该使用的结构体sockaddr_in.
>6.主要系统调用：客户端：socket, connect, send, recv, close. 服务端：socket,bind,listen,accept,recv,send,close
>  其他：recvmsg, recvfrom, sendto, shutdown, getpeername, getsockopt, setsockopt, htons, ntohs, htonl, ntohl
>
>
>**第六章**
>
>1.允许用户在调用客户软件时指明服务器地址，可以使客户软件更具一般性，并且改变服务器位置成为可能。  
>2.inet_addr把点分十进制转换成点分二进制。gethostbyname把域名转换成IP地址。返回是hostent结构体。
>3.getservbyname由服务名字和协议查找端口，返回servent结构体。
>4.getprotobyname由名字查找协议，返回protoent结构体。这个结构体包含了协议的符号常量值。
>5.TCP客户端算法：确定服务器IP和port，分配socket，指定本地IP和port，连接到服务器，使用应用级协议与服务器通信，关闭连接。
>6.客户可以允许TCP自动选择本地端口，connect调用的一个副效应就是所选择的本地端口能满足自动分配端口。
>7.对于本地多接口多IP问题：因为选取正确的本地IP要求应用程序与IP选录软件交互，TCP客户软件往往将本地端点地址放置不填，
>  而允许TCP/IP软件自动选取正确的本地IP地址和未使用的本地协议端口号。
>8.由于TCP并不保持记录的边界，所以从TCP连接中进行接收的任何程序都必须准备一次只接收几个字节的数据。
>  即使在发送应用程序一次发送一大块数据时，此规则也成立。
>9.shutdown系统调用可以指定方向来关闭连接，例如结束发送请求后不在连接，就调用shutdown(2,1)。
>10.UDP客户端算法：和TCP的区别在于没有调用connect连接。所以对于connect和shutdown的调用都没有用。
>
>
