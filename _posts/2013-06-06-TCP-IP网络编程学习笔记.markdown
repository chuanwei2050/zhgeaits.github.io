---
layout: post
title:  "TCP/IP网络编程学习笔记"
date:   2013-06-06 20:12:03
categories: Unix
type: technology
---

>_这个手记记录我学习Unix下的TCP/IP网络编程的一些知识点和重要的理解，还包含了一些遇到的错误以及解决方法。这个日志会一直更新。_
>
>**第一章**
>
>__1\.__事实上，只要一个程序员设计了两个使用TCP/IP通信的程序，这个程序员就已经发明了一种新的应用协议。  
>__2\.__TELNET协议可以用来访问不同于标准的远程登录服务的其他服务。  
>__3\.__所有的协议设计的目的都是寻找一个适用于多种应用的基本抽象。
>
>**第二章**
>
>__1\.__服务器要处理的安全问题：鉴别，授权，数据安全，保密，保护。  
>__2\.__在设计客户应用软件时，最好让它包含一些允许用户全部指明目的机器和目的协议端口号的参数。
>
>**第三章**
>
>__1\.__一个进程包括一段地址空间和至少一个执行的线程。线程最重要的信息是一个指令指针，他指明进程正在执行的地址。  
>__2\.__当多个线程并发执行一段代码时，每个线程拥有自己的过程激活记录运行时栈（run-time stack）。  
>__3\.__select调用：它允许一个程序询问操作系统哪个IO设备已准备就绪。这里IO设备包括TCP。当某个输入源就绪后，select调用立即返回，程序就可以从这个输入源中读取数据了。  
>__4\.__对一个单处理器的体系结构来说，单个CPU在任一时刻只能执行一个线程。  
>
>**第四章**
>
>__1\.__Unix IO的六个基本操作API：open, close, read, write, lseek, ioctl。  
>__2\.__TCP/IP协议加入unix的时候，扩展了I/O操作；首先是扩展了文件描述符集，加入了socket的描述符，其次read/write可以给socket描述符写数据。
>
>**第五章**
>
>__1\.__套接字API提供了许多综合的功能，这些功能支持使用众多可能的协议进行网络通信。套接字调用把所有TCP/IP协议看作一个单一的协议族。这些调用允许程序员指明所要求的服务而不是指明某个特定的协议的名字。  
>__2\.__socket()本质是分配了一个数据结构，里面还没有信息或者信息不全。  
>__3\.__如果服务器将套接字配置为等待传入连接，则称为被动（passive）套接字；反之，客户用来发起连接的套接字称为主动（active）套接字。  
>__4\.__TCP/IP协议族表示为PF_INET,地址族表示为AF_INET，两个符号常量都是2。  
>__5\.__为使程序可移植和可维护，TCP/IP代码不能在声明中使用sockaddr结构。这种结构只能用于覆盖，而且代码只能引用该结构中的sa_family字段。应该使用的结构体sockaddr_in。  
>__6\.__主要系统调用：客户端：socket, connect, send, recv, close\. 服务端：socket,bind,listen,accept,recv,send,close。  
>  其他：recvmsg, recvfrom, sendto, shutdown, getpeername, getsockopt, setsockopt, htons, ntohs, htonl, ntohl。
>
>**第六章**
>
>__1\.__允许用户在调用客户软件时指明服务器地址，可以使客户软件更具一般性，并且改变服务器位置成为可能。  
>__2\.__inet_addr把点分十进制转换成点分二进制。gethostbyname把域名转换成IP地址。返回是hostent结构体。  
>__3\.__getservbyname由服务名字和协议查找端口，返回servent结构体。  
>__4\.__getprotobyname由名字查找协议，返回protoent结构体。这个结构体包含了协议的符号常量值。  
>__5\.__TCP客户端算法：确定服务器IP和port，分配socket，指定本地IP和port，连接到服务器，使用应用级协议与服务器通信，关闭连接。  
>__6\.__客户可以允许TCP自动选择本地端口，connect调用的一个副效应就是所选择的本地端口能满足自动分配端口。  
>__7\.__对于本地多接口多IP问题：因为选取正确的本地IP要求应用程序与IP选录软件交互，TCP客户软件往往将本地端点地址放置不填，而允许TCP/IP软件自动选取正确的本地IP地址和未使用的本地协议端口号。  
>__8\.__由于TCP并不保持记录的边界，所以从TCP连接中进行接收的任何程序都必须准备一次只接收几个字节的数据。即使在发送应用程序一次发送一大块数据时，此规则也成立。  
>__9\.__shutdown系统调用可以指定方向来关闭连接，例如结束发送请求后不在连接，就调用shutdown(2,1)。  
>__10\.__UDP客户端算法：和TCP的区别在于没有调用connect连接。所以对于connect和shutdown的调用都没有用。  
>
>**第七章**
>
>__1\.__例子库使用
{% highlight c %}
extern int errno;
strerror(errno);
{% endhighlight %}
则必须
{% highlight c %}
#include <errno.h>
{% endhighlight %}
否则报Segmentation fault错误。  
>__2\.__对于linux下的TIME和ECHO服务，可以安装openbsd-inet来启动。  
>__3\.__daytime和time服务不同，daytime服务意在为人所用，而time服务意在为那些存储或维护时间的程序所使用。  
>  即daytime服务返回的是时间字符串，而time服务返回的是时间戳，从1900.1.1开始，这是国际标准时间！  
>  但是UNIX的时间是从1970.1.1开始的，所以适当修改一下，减去一个差值就可以。  
>__4\.__书上的例程是daytime用TCP实现，time用UDP实现。我写的时候，弄错了一个地方，就是sizeof和strlen弄混了，所以一直时间错误，这两个的区别，我已经记录在C语言的学习记录哪里了。  
>__5\.__对于htonl,htons,ntohl,ntohs这写字节顺序转换函数，由于不同机器的字节顺序不一样，有些是大端，有些是小端的，因此TCP/IP协议统一规定了网络字节顺序，其实就是大端字节顺序，因此不管本地是大端还是小端（一般这个对用户来说是透明的），在发送之前都要转换成网络字节顺序，收到以后都要从网络字节顺序转换成本地字节顺序。  
>注意的是，是字节顺序，不是位顺序，也就是说，一个字节里面的8位顺序是对的，只是每个字节的排序反了过来。还有，要明白，这字节顺序一般是对数而言的，特别是整型数，如果你在网络上传输一个数，那么要先把这个数转换成网络字节顺序再一个字节一个字节地传。对方接收以后如果知道是整型数，就转转成本地字节顺序，其他都按照字节来接收。因此一般的字符串，字节顺序是不变的。  
>
>**第八章**
>
>__1\.__双工传输：在任何时候，单个TCP连接都允许同时双向传送数据，且互不影响。  
>__2\.__当为套接字指明本地端点时，服务器使用INADDR_ANY以取代某个特定的IP地址，这就允许套接字接收发给该机器的人一个IP地址的数据报。  
>__3\.__循环连接的服务器算法：创建套接字并绑定端口（socket，bind），设置端口为被动模式（listen），接受一个连接（accept），读取客户请求并响应（read，write），关闭连接（close）。  
>__4\.__循环无连接的服务器算法：创建套接字并绑定端口，重复读取客户的请求并响应。  
>__5\.__并发无连接的服务器算法：主线程创建套接字并绑定端口，反复调用recvfrom接收下一个请求并创建从线程处理相应。从线程调用sendto响应请求，退出。  
>__6\.__并发连接的服务器算法：主线程创建套接字并绑定端口，设置被动模式，反复调用accept直到有一个请求就创建一个从线程处理，从线程用该连接与客户端交互，关闭退出。  
>__7\.__异步的单线程并发算法：创建套接字并绑定端口，将该套接字加到一个表，该表是可以进行IO的描述符，使用select在已有的套接字等待IO，如果最初的套接字准备就绪，使用accept获得下一个连接，并把该连接加入到表中，如果是其套接字准备就绪，就进行相应，不断循环。
>
>**第九章**
>
>__1\.__recvfrom读取数据到缓存，返回实际接收的字符数，如果接收字符数大于buffer区，则丢弃。  
>__2\.__io操作函数，可以用扩展的UNIX I/O，read/write，fprintf等,也可以用TCP/IP的recv和send调用。  
>
>**第十章**
>
>__1\.__循环的面向连接的服务器就是一个死循环的程序，使用TCP连接，每次accept一次请求，做完处理以后就关闭套接字。  
>__2\.__TCP服务端程序有一定的脆弱性，这个暂时不是很理解，因为这与TCP的实现有关，网络方面有点忘记了。  
>
>**第十一章**  
>__1\.__这个并发的面向连接的服务器就是用tcp连接，使用fork来创建子进程，然后用子进程处理请求，注意的是fork完全复制了描述符，在子进程要关闭主socket，在父进程要关闭从socket。  
>__2\.__第二个问题是用fork复制的进程会引入一个不完全终止的进程问题。linux解决这个问题是子进程退出的时候发一个信号给父进程，然后父进程调用wait3函数，在Unix初级编程那里学过wait调用是阻塞等待子进程退出，然后获得子进程退出的exit值。  
>__3\.__僵尸进程意思是，进程退出后，还有一些资源没有释放，例如pid等，要父进程调用wait才能释放，这就是僵尸进程。  
>__4\.__这里有几个问题，第一，父进程接收信号时，accept被中断，然后收到一个errno，然后退出循环。这个问题可以处理accept的返回-1。第二,如果多个子进程同时退出是，父进程接收多个信号，但是信号不缓存，所以只能处理一个信号，其他丢失了。因此使用waitpid调用。书上使用wait3的原因，它包含了waitpid的功能，还可以指向子进程的资源结构rusage，并且可以设置wait3不阻塞。  
